package $namespace

import (
	//Official libs
	"bytes"
	"fmt"
	#if $obj.need_strconv
	"strconv"
	#end if

	//3rd party libs
	"labix.org/v2/mgo"
	"labix.org/v2/mgo/bson"
	"github.com/sipin/gothrift/thrift"
	"github.com/sipin/gorazor/gorazor"
	#if $obj.need_search
	"github.com/mattbaird/elastigo/core"
	#end if

	//Own libs
	"db"
)

type $obj.name.value struct {
	#for field in $obj.fields
		#if $field.name.value == "ID"
	ID         bson.ObjectId `bson:"_id" thrift:"$field.name.value,$field.tag"`
		#else
	$field.name.value  $field.go_type `bson:"$field.name.value" thrift:"$field.name.value,$field.tag"`
	_${field.name.value}Widget *gorazor.Widget
		#end if
	#end for
}

#for key, fields in $obj.search.iteritems()
type $(obj.name.value)Search$(key)Obj struct {
	#for field in fields
	$field string `json:"$(field)"`
	#end for
}
#end for

func New$(obj.name.value)() *$obj.name.value {
	rval := &$obj.name.value{}
	rval.ID = bson.NewObjectId()
	return rval
}

func New$(obj.name.value)FromBytes(data []byte) *$obj.name.value {
	o := &$obj.name.value{}
	transport := thrift.NewStreamTransportR(bytes.NewBuffer(data))
	protocol := thrift.NewTCompactProtocol(transport)
	o.Read(protocol)
	return o
}

//Thrift Methods

func (p *$obj.name.value) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
#for field in $obj.fields
		case $field.tag:
			if err := p.readField$(field.tag)(iprot); err != nil {
				return err
			}
#end for
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

#for field in $obj.fields
func (p *$obj.name.value) readField$(field.tag)(iprot thrift.TProtocol) error {
	#if $field.type == "string"
	if v, err := iprot.ReadString(); err != nil {
	#else if $field.type == "i32"
	if v, err := iprot.ReadI32(); err != nil {
	#else if $field.type == "i64"
	if v, err := iprot.ReadI64(); err != nil {
	#else if $field.type == "bool"
	if v, err := iprot.ReadBool(); err != nil {
	#else
	Change go.tmpl go support $field.type now!
	#end if
		return fmt.Errorf("error reading field $(field.tag): %s", err)
	} else {
		#if $field.name.value == "ID"
		p.$field.name.value = bson.ObjectId(v)
		#else
		p.$field.name.value = v
		#end if
	}
	return nil
}
#end for

func (p *$obj.name.value) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("$obj.name.value"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
#for field in $obj.fields
	if err := p.writeField$(field.tag)(oprot); err != nil {
		return err
	}
#end for
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

#for field in $obj.fields
func (p *$obj.name.value) writeField$(field.tag)(oprot thrift.TProtocol) (err error) {
	#if $field.type == "string"
	if err := oprot.WriteFieldBegin("$field.name.value", thrift.STRING, $field.tag); err != nil {
		return fmt.Errorf("%T write field begin error $field.type:$field.name.value: %s", p, err)
	}
	if err := oprot.WriteString(string(p.$field.name.value)); err != nil {
	#else if $field.type == "i32"
	if err := oprot.WriteFieldBegin("$field.name.value", thrift.I32, $field.tag); err != nil {
		return fmt.Errorf("%T write field begin error $field.type:$field.name.value: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.$field.name.value)); err != nil {
	#else if $field.type == "i64"
	if err := oprot.WriteFieldBegin("$field.name.value", thrift.I64, $field.tag); err != nil {
		return fmt.Errorf("%T write field begin error $field.type:$field.name.value: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.$field.name.value)); err != nil {
	
	#else if $field.type == "bool"
	if err := oprot.WriteFieldBegin("$field.name.value", thrift.BOOL, 9); err != nil {
		return fmt.Errorf("%T write field begin error 9:IsAdmin: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.$field.name.value)); err != nil {
	#else
	Change go.tmpl go support $field.type now!
	#end if
		return fmt.Errorf("%T.$field.name.value ($field.type) field write error: %s", p, err)
	}

	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ID: %s", p, err)
	}
	return err
}
#end for

func (p *$obj.name.value) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("$(obj.name.value)(%+v)", *p)
}

func (p *$obj.name.value) ToBytes() []byte {
	transport := thrift.NewTMemoryBuffer()
	protocol := thrift.NewTCompactProtocol(transport)
	p.Write(protocol)
	protocol.Flush()

	return transport.Bytes()
}

//mongo methods

func (o *$obj.name.value) Save() (info *mgo.ChangeInfo, err error) {
	session, col := db.GetCol("$obj.name.value")
	defer session.Close()

	if o.ID == "" {
		o.ID = bson.NewObjectId()
	}

	#for key, fields in $obj.search.iteritems()
	core.Index("$(obj.name.value.lower())", "$(key.lower())", o.ID.Hex(), nil, $(obj.name.value)Search$(key)Obj{
		#for field in fields
		o.$(field),
		#end for
	})
	#end for


	return col.UpsertId(o.ID, o)
}

//Form methods

func (o *$obj.name.value) ReadForm(params map[string]string) {
#for field in $obj.fields
#if $field.name.value != "ID"
	if val, ok := params["$field.name.value"]; ok {
	#if $field.type == "string"
		o.$field.name.value = val
	#else if $field.type == "i32"
		intVal, _ := strconv.Atoi(val)
		o.$field.name.value = int32(intVal)
	#else if $field.type == "i64"
		intVal, _ := strconv.ParseInt(val, 10, 64)
		o.$field.name.value = intVal
	#else if $field.type == "bool"
		o.$field.name.value = (val != "")
	#else
	Change go.tmpl go support $field.type now!
	#end if
	#if $field.type == "bool"
	} else {
		o.$field.name.value = false	
	#end if
	}
#end if
#end for
}

#for field in $obj.fields
#if $field.name.value != "ID"
func (o *$obj.name.value) ${field.name.value}Widget() *gorazor.Widget {
	if o._${field.name.value}Widget == nil {
		o._${field.name.value}Widget = &gorazor.Widget{
				Label: "$field.label",
			#if $field.type == "string"
				Value : o.$field.name.value,
			#else if $field.type == "i32"
				Value : strconv.FormatInt(int64(o.$field.name.value), 10),
			#else if $field.type == "i64"
				Value : strconv.FormatInt(o.$field.name.value, 10),
			#else if $field.type == "bool"
				Value : strconv.FormatBool(o.$field.name.value),
			#else
			Change go.tmpl go support $field.type now!
			#end if
				Name: "$field.name.value",
				PlaceHolder: "",
				Type: "$field.type",
			}
	}

	return o._${field.name.value}Widget
}
#end if
#end for

func (o *$obj.name.value) Widgets() []*gorazor.Widget {
	return []*gorazor.Widget{
#for field in $obj.fields
#if $field.name.value != "ID"
		o.${field.name.value}Widget(),
#end if
#end for
	}
}

//foreigh keys

#for field in $obj.fields
	#if $field.foreign != ""
func (p *$obj.name.value) Get$(field.foreign)() (result *$field.foreign, err error) {
	return $(field.foreign)FindByID(p.$field.name.value)
}

func (p *$obj.name.value) Set$(field.foreign)(obj *$field.foreign) {
	p.$field.name.value = obj.ID.Hex()
}

func (o *$field.foreign) GetAll$(obj.name.value)() (result []*$obj.name.value, err error) {
	query := bson.M{"$(field.foreign)ID": o.ID.Hex()}
	return $(obj.name.value)FindAll(query)
}
	#end if
#end for


//Collection Manage methods

func $(obj.name.value)FindOne(query interface{}, sortFields ...string) (result *$obj.name.value, err error) {
	session, col := db.GetCol("$obj.name.value")
	defer session.Close()

	q := col.Find(query)

	if sortFields == nil {
		q.Sort("-_id")
	} else {
		q.Sort(sortFields...)
	}

	err = q.One(&result)
	return
}

func $(obj.name.value)Find(query interface{}, limit int, offset int, sortFields ...string) (result []*$obj.name.value, err error) {
	session, col := db.GetCol("$obj.name.value")
	defer session.Close()

	q := col.Find(query).Limit(limit).Skip(offset)

	if sortFields == nil {
		q.Sort("-_id")
	} else {
		q.Sort(sortFields...)
	}

	err = q.All(&result)
	return
}

func $(obj.name.value)FindAll(query interface{}, sortFields ...string) (result []*$obj.name.value, err error) {
	session, col := db.GetCol("$obj.name.value")
	defer session.Close()

	q := col.Find(query)

	if sortFields == nil {
		q.Sort("-_id")
	} else {
		q.Sort(sortFields...)
	}

	err = q.All(&result)
	return
}

func $(obj.name.value)Count(query interface{}) (result int) {
	session, col := db.GetCol("$obj.name.value")
	defer session.Close()

	result, _ = col.Find(query).Count()
	return
}

func $(obj.name.value)FindByID(id string) (result *$obj.name.value, err error) {
	session, col := db.GetCol("$obj.name.value")
	defer session.Close()

	err = col.FindId(bson.ObjectIdHex(id)).One(&result)
	return
}

func $(obj.name.value)RemoveByID(id string) (result *$obj.name.value, err error) {
	session, col := db.GetCol("$obj.name.value")
	defer session.Close()

	err = col.RemoveId(bson.ObjectIdHex(id))
	#for key, v in $obj.search.iteritems()
	core.Delete("$(obj.name.value.lower())", "$(key.lower())", id, nil)
	#end for
	return
}

// Search
#for key, v in $obj.search.iteritems()
func $(obj.name.value)Search$(key)(word string) (core.SearchResult, error) {
	searchJson := `{
    "query" : {
        "query_string" :  {
	      "default_operator": "OR",
	      "fields": ` + `$(str(v).replace("'", '"'))` + `,
	      "query": "` + word + `"
	    }
    }
}`
	return core.SearchRequest("$(obj.name.value.lower())", "$(key.lower())", nil, searchJson)
}
#end for
