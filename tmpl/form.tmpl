//Form methods

func (w *$(obj.name.value)) initWidget() {
	w.widgets = make(map[string]*Widget, $len($obj.fields))
}

func (o *$obj.name.value) ReadForm(params map[string]string) (hasError bool) {
#for field in $obj.fields
#if $field.name.value != "ID"
	if val, ok := params["$field.name.value"]; ok {
	#if $field.type == "string"
		o.$field.name.value = val
	#else if $field.type == "i32" and $field.widget_type in ["datetime"]
		if val == "" {
			o.$field.name.value = 0
		} else {
			intVal, _ := time.Parse(DateTimeLayout, val)
			o.$field.name.value = int32(intVal.Unix())
		}
	#else if $field.type == "i32"
		intVal, _ := strconv.Atoi(val)
		#if hasattr(field, "stringList")
		if intVal <= 0 || intVal >= len(o.${field.name.value}Widget().StringList) {
			intVal = 0
		}
		#end if
		o.$field.name.value = int32(intVal)
	#else if $field.type == "i64" and $field.widget_type in ["datetime"]
		if val == "" {
			o.$field.name.value = 0
		} else {
			intVal, _ := time.Parse(DateTimeLayout, val)
			o.$field.name.value = intVal.Unix()
		}
	#else if $field.type == "i64"
		intVal, _ := strconv.ParseInt(val, 10, 64)
		o.$field.name.value = intVal
	#else if $field.type == "bool"
		o.$field.name.value = (val != "")
	#else if $field.type == "list<string>"
		o.$field.name.value = strings.Split(val, "\n")
	#else
	Change go.tmpl go support $field.type now!
	#end if
	#if $field.type == "bool"
	} else {
		o.$field.name.value = false
	#end if
	}
#end if
#end for
	return o.ValidateData()
}

func (o *$obj.name.value) ValidateData() (hasError bool) {
#for field in $obj.fields
	#if field.required and hasattr(field, "rule")
	if o.$field.name.value == "" {
		hasError = true
		o.${field.name.value}Widget().ErrorMsg = "$field.requiredMsg"
	} else {
		if !regexp.MustCompile(`$field.rule`).Match([]byte(o.$field.name.value)) {
			hasError = true
			o.${field.name.value}Widget().ErrorMsg = "$field.ruleMsg"
		}
	}
	#else if field.required
		#if $field.type == "string"
	if o.$field.name.value == "" {
		#elif $field.type in ["i32", "i64"]
	if o.$field.name.value == 0 {
		#end if
		o.${field.name.value}Widget().ErrorMsg = "$field.requiredMsg"
		hasError = true
	}
	
	#else if hasattr(field, "rule")
	if !regexp.MustCompile(`$field.rule`).Match([]byte(o.$field.name.value)) {
		o.${field.name.value}Widget().ErrorMsg = "$field.ruleMsg"
		hasError = true
	}
	#end if
#end for
	return
}

#for field in $obj.fields
#if $field.name.value != "ID"
func (o *$obj.name.value) ${field.name.value}Widget() *Widget {
	name := "${field.name.value}"
	ret, ok := o.widgets[name]
	if !ok || ret==nil {
		ret = &Widget{
			Label: "$field.label",
		#if $field.type == "string"
			Value : o.$field.name.value,
		#else if $field.type == "i32" and $field.widget_type in ["datetime"]
			Value : I32Time(o.$field.name.value),
		#else if $field.type == "i32" 
			Value : strconv.FormatInt(int64(o.$field.name.value), 10),
		#else if $field.type == "i64" and $field.widget_type in ["datetime"]
			Value : I64Time(o.$field.name.value),
		#else if $field.type == "i64" 
			Value : strconv.FormatInt(o.$field.name.value, 10),
		#else if $field.type == "bool"
			Value : strconv.FormatBool(o.$field.name.value),
		#else if $field.type == "list<string>"
			Value : strings.Join(o.$field.name.value, "\n"),
		#else
		Change go.tmpl go support $field.type now!
		#end if
			Name: "$field.name.value",
			PlaceHolder: "",
			Type: "$field.widget_type",
		#if hasattr($field, "enums")
			EnumData : $(namespace).$(field.enums)Label,
		#else if hasattr($field, "stringList")
			StringList : $(filename).$field.stringList,
		#else if hasattr($field, "bindData")
			GetBindData : $field.bindData,
		#end if
		}
		if o.widgets == nil {
			o.initWidget()
		}
		o.widgets[name] = ret
	}

	return ret
}
#end if
#end for

func (o *$obj.name.value) GetListedLabels() []*IDLabelPair {
	return []*IDLabelPair{
		#for field in $obj.listedFields
		&IDLabelPair {
			ID : "$field.name.value",
			Label : "$field.label",
		},
		#end for
	}
}

func (o *$obj.name.value) Id() string {
	return o.ID.Hex()
}

func (o *$obj.name.value) GetLabel() string {
	return "$obj.label"
}

func (o *$obj.name.value) GetFieldAsString(fieldKey string) (Value string) {
	switch fieldKey {
#for field in $obj.fields
	case "$field.name.value":
	#if $field.name.value == "ID"
		Value = o.ID.Hex()
	#else if $field.type == "string"
		Value = o.$field.name.value
	#else if $field.type == "i32" and $field.widget_type in ["datetime"]
		Value = I32Time(o.$field.name.value)
	#else if $field.type == "i32" 
		Value = strconv.FormatInt(int64(o.$field.name.value), 10)
	#else if $field.type == "i64" and $field.widget_type in ["datetime"]
		Value = I64Time(o.$field.name.value)
	#else if $field.type == "i64" 
		Value = strconv.FormatInt(o.$field.name.value, 10)
	#else if $field.type == "bool"
		Value = strconv.FormatBool(o.$field.name.value)
	#else if $field.type == "list<string>"
		Value = strings.Join(o.$field.name.value, "\n")
	#else
	Change go.tmpl go support $field.type now!
	#end if
#end for
	}
	return
}


func (o *$obj.name.value) Widgets() []*Widget {
	return []*Widget{
#for field in $obj.fields
#if $field.name.value != "ID"
		o.${field.name.value}Widget(),
#end if
#end for
	}
}
