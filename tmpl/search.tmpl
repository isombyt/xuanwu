//Search
#if $obj.search != None
type $(obj.name.value)SearchObj struct {
	#for field in $obj.search
	$field string `json:"$(field)"`
	#end for
}

func (o *$obj.name.value) IndexSearch() () {
	core.Index("$(obj.name.value.lower())", "simple", o.ID.Hex(), nil, $(obj.name.value)SearchObj{
		#for field in $obj.search
		o.$(field),
		#end for
	})
}

func $(obj.name.value)GetSearchObj(word string) map[string]interface {} {
	//todo: should be able to cache struct
	queryString := make(map[string]interface{})
	queryString["default_operator"] = "OR"
	queryString["fields"] = []string{
		#for field in $obj.search
		"$(field)",
		#end for
	}
	queryString["query"] = word
	query := make(map[string]interface{})
	query["query_string"] = queryString

	args := make(map[string]interface{})
	args["query"] = query
	return args
}

func $(obj.name.value)Search(word string, limit int, offset int) (core.SearchResult, error) {
	searchObj := $(obj.name.value)GetSearchObj(word)
	args := map[string]interface{} {"from" : offset, "size": limit}
	return core.SearchRequest("$(obj.name.value.lower())", "simple", args, searchObj)
}

func $(obj.name.value)SearchPurge() {
	core.Delete("$(obj.name.value.lower())", "simple", "", nil)
}

func $(obj.name.value)SearchRebuild() {
	$(obj.name.value)SearchPurge()
	total := $(obj.name.value)Count(nil)
	step := 100
	start := 0
	for start < total {
		objs, _ := $(obj.name.value)Find(nil, step, start)
		for _, o := range objs {
			o.IndexSearch()
		}
		start += len(objs)
	}
}
#end if

func (o *$obj.name.value) IsSearchEnabled() bool {
#if $obj.search != None
	return true
#else
	return false
#end if
}

//end search